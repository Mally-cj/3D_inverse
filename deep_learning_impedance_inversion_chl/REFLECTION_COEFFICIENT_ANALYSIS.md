# 代码中反射系数计算方法分析

## 🔍 问题分析：代码使用的是线性还是非线性方法？

基于对代码的详细分析，**代码使用的是线性方法**。

## 📊 证据分析

### 1. 对数变换证据
```python
# 在数据加载部分（第102行）
impedance_model_full = np.log(impedance_model_full)
```
**关键**：代码对阻抗数据进行了对数变换，这是线性方法的标志性特征。

### 2. 反射系数计算实现
```python
def DIFFZ(z):
    """
    计算阻抗的空间梯度，得到反射系数
    输入: z - 阻抗数据 [batch, channel, time, space]  # 注意：这里的z是log(Z)
    输出: DZ - 反射系数 [batch, channel, time, space]
    """
    DZ = torch.zeros([z.shape[0], z.shape[1], z.shape[2], z.shape[3]], device=device).type(dtype)
    DZ[..., :-1, :] = 0.5 * (z[..., 1:, :] - z[..., :-1, :])  # 计算相邻层的差值
    return DZ
```

### 3. 数学原理对应

根据理论，线性方法的公式是：
$$r(t) \approx \frac{1}{2} \frac{d\ln Z(t)}{dt}$$

代码实现完全对应这个公式：
1. **对数变换**：`np.log(impedance_model_full)` → 得到 $\ln Z(t)$
2. **差分运算**：`0.5 * (z[..., 1:, :] - z[..., :-1, :])` → 计算 $\frac{1}{2} \frac{d\ln Z(t)}{dt}$

### 4. 与理论的精确对应

| 理论公式 | 代码实现 | 说明 |
|---------|----------|------|
| $\ln Z(t)$ | `np.log(impedance_model_full)` | 对数阻抗 |
| $\frac{d\ln Z(t)}{dt}$ | `z[..., 1:, :] - z[..., :-1, :]` | 对数阻抗的差分 |
| $\frac{1}{2} \frac{d\ln Z(t)}{dt}$ | `0.5 * (z[..., 1:, :] - z[..., :-1, :])` | 线性反射系数 |

## ✅ 结论

**代码使用的是线性方法**，具体特征：

1. **对数变换**：将原始阻抗 $Z$ 转换为 $\ln Z$
2. **线性差分**：计算对数阻抗的梯度
3. **系数因子**：使用 0.5 作为缩放因子
4. **适用场景**：小角度入射假设下的反射系数计算

## 🔬 实现优势

线性方法的优势：
- **数值稳定**：对数变换避免了阻抗值的大范围变化
- **计算简单**：只需要简单的差分运算
- **梯度友好**：便于深度学习中的反向传播
- **物理合理**：在小角度入射假设下物理意义明确

## 💡 与非线性方法的对比

如果是非线性方法，代码应该是：
```python
# 非线性方法（代码中未使用）
def DIFFZ_nonlinear(z):  # 这里z是原始阻抗，不是对数
    numerator = z[..., 1:, :] - z[..., :-1, :]      # Z(t+Δt) - Z(t)
    denominator = z[..., 1:, :] + z[..., :-1, :]    # Z(t+Δt) + Z(t)
    return numerator / denominator
```

但代码中明确使用了对数变换和线性差分，确认是**线性方法**。
